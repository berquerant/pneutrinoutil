package pworker

import (
	"errors"
	"log/slog"
	"os"
	"path/filepath"
	"time"

	"github.com/berquerant/pneutrinoutil/pkg/logx"
	"github.com/berquerant/pneutrinoutil/pkg/pathx"
	"github.com/berquerant/pneutrinoutil/pkg/syncx"
	"github.com/berquerant/pneutrinoutil/server/alog"
)

func NewList(workDir string) *List {
	return &List{
		workDir:    workDir,
		ridMap:     syncx.NewMap[string, Result](),
		elementMap: syncx.NewMap[pathx.ResultElement, string](),
	}
}

type List struct {
	workDir    string
	ridMap     *syncx.Map[string, Result]              // rid to result
	elementMap *syncx.Map[pathx.ResultElement, string] // element to rid
}

var (
	ErrMissingRequestID = errors.New("MissingRequestID")
	ErrMissingResult    = errors.New("MissingResult")
)

func (s *List) Init() error { return s.load() }

type ListKey struct {
	RequestID string
	Element   *pathx.ResultElement
}

// ListKeys returns list of successful requests.
func (s *List) ListKeys() []*ListKey {
	m := s.elementMap.ShallowCopy()
	var (
		keys = make([]*ListKey, len(m))
		i    int
	)
	for k, v := range m {
		keys[i] = &ListKey{
			RequestID: v,
			Element:   &k,
		}
		i++
	}
	return keys
}

func (s *List) Load(rid string) (Result, error) {
	if r, ok := s.ridMap.Get(rid); ok {
		return r, nil
	}
	if err := s.load(); err != nil {
		return nil, err
	}
	if r, ok := s.ridMap.Get(rid); ok {
		return r, nil
	}
	return nil, ErrMissingResult
}

func (s *List) resultDir() string { return filepath.Join(s.workDir, "result") }

func (s *List) load() error {
	entries, err := os.ReadDir(s.resultDir())
	if err != nil {
		return err
	}

	for _, entry := range entries {
		if err := s.loadElement(entry); err != nil {
			alog.L().Warn("ignore result element",
				slog.String("dir", filepath.Join(s.resultDir(), entry.Name())),
				logx.Err(err),
			)
		}
	}

	return nil
}

func (s *List) loadElement(entry os.DirEntry) error {
	re, err := LoadResultElement(entry)
	if err != nil {
		return err
	}

	if _, exist := s.elementMap.Get(*re); exist {
		// cached
		return nil
	}

	c, err := LoadResultConfig(s.resultDir(), re)
	if err != nil {
		return err
	}

	rid := c.Description
	if rid == "" {
		// should have request id if generated by Start handler
		return ErrMissingRequestID
	}
	if _, exist := s.ridMap.Get(rid); exist {
		// cached
		return nil
	}

	r := NewSuccessResult(
		rid,
		filepath.Join(s.resultDir(), re.String()),
		c,
		re,
	)

	alog.L().Info("load result",
		slog.String("dir", filepath.Join(s.resultDir(), entry.Name())),
		slog.String("id", rid),
		slog.String("basename", re.Basename),
		slog.String("created_at", re.Now.Format(time.DateTime)),
		slog.Int("salt", re.Salt),
	)
	s.ridMap.Set(rid, r)
	s.elementMap.Set(*re, rid)

	return nil
}

// Fail registers failed request.
func (s *List) Fail(rid string, err error) {
	r := NewErrorResult(rid, err)
	s.ridMap.Set(rid, r)
}
