/* tslint:disable */
/* eslint-disable */
/**
 * pneutrinoutil API
 * pneutrinoutil http server
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface CtlConfig {
    'desc'?: string;
    'enhanceBreathiness'?: number;
    'formantShift'?: number;
    'inference'?: number;
    /**
     * NEUTRINO
     */
    'model'?: string;
    'modelData'?: object;
    /**
     * Info
     */
    'neutrinoVersion'?: string;
    'parallel'?: number;
    /**
     * NSF
     */
    'pitchShiftNsf'?: number;
    /**
     * WORLD
     */
    'pitchShiftWorld'?: number;
    'randomSeed'?: number;
    /**
     * musicXML_to_label Suffix string `yaml:\"suffix\"` Project settings
     */
    'score'?: string;
    'smoothFormant'?: number;
    'smoothPitch'?: number;
    'styleShift'?: number;
    'supportModel'?: string;
    'supportModelData'?: object;
    'thread'?: number;
    'transpose'?: number;
}
export interface HandlerDebugResponseData {
    'routes'?: object;
}
export interface HandlerErrorResponse {
    'error'?: string;
    /**
     * false
     */
    'ok'?: boolean;
}
export interface HandlerGetDetailResponseData {
    /**
     * original musicxml file name except extension
     */
    'basename'?: string;
    'command'?: string;
    'completed_at'?: string;
    'created_at'?: string;
    /**
     * request id, or just id
     */
    'rid'?: string;
    'started_at'?: string;
    'status'?: string;
}
export interface HandlerSearchProcessResponseDataElement {
    'command'?: string;
    'completed_at'?: string;
    'created_at'?: string;
    /**
     * request id, or just id
     */
    'request_id'?: string;
    'started_at'?: string;
    'status'?: string;
    'title'?: string;
    'updated_at'?: string;
}
export interface HandlerSuccessResponseCtlConfig {
    'data'?: CtlConfig;
    /**
     * true
     */
    'ok'?: boolean;
}
export interface HandlerSuccessResponseHandlerDebugResponseData {
    'data'?: HandlerDebugResponseData;
    /**
     * true
     */
    'ok'?: boolean;
}
export interface HandlerSuccessResponseHandlerGetDetailResponseData {
    'data'?: HandlerGetDetailResponseData;
    /**
     * true
     */
    'ok'?: boolean;
}
export interface HandlerSuccessResponseHandlerSearchProcessResponseData {
    'data'?: Array<HandlerSearchProcessResponseDataElement>;
    /**
     * true
     */
    'ok'?: boolean;
}
export interface HandlerSuccessResponseHandlerVersionResponseData {
    'data'?: HandlerVersionResponseData;
    /**
     * true
     */
    'ok'?: boolean;
}
export interface HandlerSuccessResponseString {
    'data'?: string;
    /**
     * true
     */
    'ok'?: boolean;
}
export interface HandlerVersionResponseData {
    /**
     * commit hash
     */
    'revision'?: string;
    /**
     * server version
     */
    'version'?: string;
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * debug info
         * @summary debug info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/debug`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * health check
         * @summary health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * download pneutrinoutil config as json
         * @summary download config
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdConfigGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('procIdConfigGet', 'id', id)
            const localVarPath = `/proc/{id}/config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get process info
         * @summary get process info
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdDetailGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('procIdDetailGet', 'id', id)
            const localVarPath = `/proc/{id}/detail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * download process log file
         * @summary download log
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdLogGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('procIdLogGet', 'id', id)
            const localVarPath = `/proc/{id}/log`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * download musicxml file
         * @summary download musicxml
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdMusicxmlGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('procIdMusicxmlGet', 'id', id)
            const localVarPath = `/proc/{id}/musicxml`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * download wav file generated by pneutrinoutil
         * @summary download wav
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdWavGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('procIdWavGet', 'id', id)
            const localVarPath = `/proc/{id}/wav`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * download world wav file generated by pneutrinoutil (before NEUTRINO v3)
         * @summary download world wav
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdWorldWavGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('procIdWorldWavGet', 'id', id)
            const localVarPath = `/proc/{id}/world_wav`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * start a pneutrinoutil process with given arguments
         * @summary start a process
         * @param {File} score musicxml
         * @param {number} [enhanceBreathiness] [0, 100]%, default: 0 (before NEUTRINO v3)
         * @param {number} [formantShift] default: 1.0 (before NEUTRINO v3)
         * @param {number} [inference] [2, 3, 4], default: 2 (before NEUTRINO v3)
         * @param {string} [model] default: MERROW
         * @param {string} [supportModel] (NEUTRINO v3)
         * @param {number} [transpose] default: 0 (NEUTRINO v3)
         * @param {number} [pitchShiftNsf] default: 0 (before NEUTRINO v3)
         * @param {number} [pitchShiftWorld] default: 0 (before NEUTRINO v3)
         * @param {number} [smoothFormant] [0, 100]%, default: 0 (before NEUTRINO v3)
         * @param {number} [smoothPitch] [0, 100]%, default: 0 (before NEUTRINO v3)
         * @param {number} [styleShift] default: 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procPost: async (score: File, enhanceBreathiness?: number, formantShift?: number, inference?: number, model?: string, supportModel?: string, transpose?: number, pitchShiftNsf?: number, pitchShiftWorld?: number, smoothFormant?: number, smoothPitch?: number, styleShift?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('procPost', 'score', score)
            const localVarPath = `/proc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (score !== undefined) { 
                localVarFormParams.append('score', score as any);
            }
    
            if (enhanceBreathiness !== undefined) { 
                localVarFormParams.append('enhanceBreathiness', enhanceBreathiness as any);
            }
    
            if (formantShift !== undefined) { 
                localVarFormParams.append('formantShift', formantShift as any);
            }
    
            if (inference !== undefined) { 
                localVarFormParams.append('inference', inference as any);
            }
    
            if (model !== undefined) { 
                localVarFormParams.append('model', model as any);
            }
    
            if (supportModel !== undefined) { 
                localVarFormParams.append('supportModel', supportModel as any);
            }
    
            if (transpose !== undefined) { 
                localVarFormParams.append('transpose', transpose as any);
            }
    
            if (pitchShiftNsf !== undefined) { 
                localVarFormParams.append('pitchShiftNsf', pitchShiftNsf as any);
            }
    
            if (pitchShiftWorld !== undefined) { 
                localVarFormParams.append('pitchShiftWorld', pitchShiftWorld as any);
            }
    
            if (smoothFormant !== undefined) { 
                localVarFormParams.append('smoothFormant', smoothFormant as any);
            }
    
            if (smoothPitch !== undefined) { 
                localVarFormParams.append('smoothPitch', smoothPitch as any);
            }
    
            if (styleShift !== undefined) { 
                localVarFormParams.append('styleShift', styleShift as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search processes by status, created_at, title prefix, order by created_at desc
         * @summary search processes
         * @param {number} [limit] query limit; default: 5
         * @param {string} [prefix] title prefix
         * @param {string} [status] process status; (pending|running|succeed|failed)
         * @param {string} [start] created_at
         * @param {string} [end] created_at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procSearchGet: async (limit?: number, prefix?: string, status?: string, start?: string, end?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/proc/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get server version
         * @summary get server version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * debug info
         * @summary debug info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlerSuccessResponseHandlerDebugResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.debugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * health check
         * @summary health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlerSuccessResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * download pneutrinoutil config as json
         * @summary download config
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async procIdConfigGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlerSuccessResponseCtlConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.procIdConfigGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.procIdConfigGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get process info
         * @summary get process info
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async procIdDetailGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlerSuccessResponseHandlerGetDetailResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.procIdDetailGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.procIdDetailGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * download process log file
         * @summary download log
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async procIdLogGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.procIdLogGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.procIdLogGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * download musicxml file
         * @summary download musicxml
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async procIdMusicxmlGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.procIdMusicxmlGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.procIdMusicxmlGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * download wav file generated by pneutrinoutil
         * @summary download wav
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async procIdWavGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.procIdWavGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.procIdWavGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * download world wav file generated by pneutrinoutil (before NEUTRINO v3)
         * @summary download world wav
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async procIdWorldWavGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.procIdWorldWavGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.procIdWorldWavGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * start a pneutrinoutil process with given arguments
         * @summary start a process
         * @param {File} score musicxml
         * @param {number} [enhanceBreathiness] [0, 100]%, default: 0 (before NEUTRINO v3)
         * @param {number} [formantShift] default: 1.0 (before NEUTRINO v3)
         * @param {number} [inference] [2, 3, 4], default: 2 (before NEUTRINO v3)
         * @param {string} [model] default: MERROW
         * @param {string} [supportModel] (NEUTRINO v3)
         * @param {number} [transpose] default: 0 (NEUTRINO v3)
         * @param {number} [pitchShiftNsf] default: 0 (before NEUTRINO v3)
         * @param {number} [pitchShiftWorld] default: 0 (before NEUTRINO v3)
         * @param {number} [smoothFormant] [0, 100]%, default: 0 (before NEUTRINO v3)
         * @param {number} [smoothPitch] [0, 100]%, default: 0 (before NEUTRINO v3)
         * @param {number} [styleShift] default: 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async procPost(score: File, enhanceBreathiness?: number, formantShift?: number, inference?: number, model?: string, supportModel?: string, transpose?: number, pitchShiftNsf?: number, pitchShiftWorld?: number, smoothFormant?: number, smoothPitch?: number, styleShift?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlerSuccessResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.procPost(score, enhanceBreathiness, formantShift, inference, model, supportModel, transpose, pitchShiftNsf, pitchShiftWorld, smoothFormant, smoothPitch, styleShift, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.procPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * search processes by status, created_at, title prefix, order by created_at desc
         * @summary search processes
         * @param {number} [limit] query limit; default: 5
         * @param {string} [prefix] title prefix
         * @param {string} [status] process status; (pending|running|succeed|failed)
         * @param {string} [start] created_at
         * @param {string} [end] created_at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async procSearchGet(limit?: number, prefix?: string, status?: string, start?: string, end?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlerSuccessResponseHandlerSearchProcessResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.procSearchGet(limit, prefix, status, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.procSearchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get server version
         * @summary get server version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlerSuccessResponseHandlerVersionResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.versionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * debug info
         * @summary debug info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugGet(options?: RawAxiosRequestConfig): AxiosPromise<HandlerSuccessResponseHandlerDebugResponseData> {
            return localVarFp.debugGet(options).then((request) => request(axios, basePath));
        },
        /**
         * health check
         * @summary health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: RawAxiosRequestConfig): AxiosPromise<HandlerSuccessResponseString> {
            return localVarFp.healthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * download pneutrinoutil config as json
         * @summary download config
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdConfigGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<HandlerSuccessResponseCtlConfig> {
            return localVarFp.procIdConfigGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get process info
         * @summary get process info
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdDetailGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<HandlerSuccessResponseHandlerGetDetailResponseData> {
            return localVarFp.procIdDetailGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * download process log file
         * @summary download log
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdLogGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.procIdLogGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * download musicxml file
         * @summary download musicxml
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdMusicxmlGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.procIdMusicxmlGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * download wav file generated by pneutrinoutil
         * @summary download wav
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdWavGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.procIdWavGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * download world wav file generated by pneutrinoutil (before NEUTRINO v3)
         * @summary download world wav
         * @param {string} id request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procIdWorldWavGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.procIdWorldWavGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * start a pneutrinoutil process with given arguments
         * @summary start a process
         * @param {File} score musicxml
         * @param {number} [enhanceBreathiness] [0, 100]%, default: 0 (before NEUTRINO v3)
         * @param {number} [formantShift] default: 1.0 (before NEUTRINO v3)
         * @param {number} [inference] [2, 3, 4], default: 2 (before NEUTRINO v3)
         * @param {string} [model] default: MERROW
         * @param {string} [supportModel] (NEUTRINO v3)
         * @param {number} [transpose] default: 0 (NEUTRINO v3)
         * @param {number} [pitchShiftNsf] default: 0 (before NEUTRINO v3)
         * @param {number} [pitchShiftWorld] default: 0 (before NEUTRINO v3)
         * @param {number} [smoothFormant] [0, 100]%, default: 0 (before NEUTRINO v3)
         * @param {number} [smoothPitch] [0, 100]%, default: 0 (before NEUTRINO v3)
         * @param {number} [styleShift] default: 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procPost(score: File, enhanceBreathiness?: number, formantShift?: number, inference?: number, model?: string, supportModel?: string, transpose?: number, pitchShiftNsf?: number, pitchShiftWorld?: number, smoothFormant?: number, smoothPitch?: number, styleShift?: number, options?: RawAxiosRequestConfig): AxiosPromise<HandlerSuccessResponseString> {
            return localVarFp.procPost(score, enhanceBreathiness, formantShift, inference, model, supportModel, transpose, pitchShiftNsf, pitchShiftWorld, smoothFormant, smoothPitch, styleShift, options).then((request) => request(axios, basePath));
        },
        /**
         * search processes by status, created_at, title prefix, order by created_at desc
         * @summary search processes
         * @param {number} [limit] query limit; default: 5
         * @param {string} [prefix] title prefix
         * @param {string} [status] process status; (pending|running|succeed|failed)
         * @param {string} [start] created_at
         * @param {string} [end] created_at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procSearchGet(limit?: number, prefix?: string, status?: string, start?: string, end?: string, options?: RawAxiosRequestConfig): AxiosPromise<HandlerSuccessResponseHandlerSearchProcessResponseData> {
            return localVarFp.procSearchGet(limit, prefix, status, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * get server version
         * @summary get server version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet(options?: RawAxiosRequestConfig): AxiosPromise<HandlerSuccessResponseHandlerVersionResponseData> {
            return localVarFp.versionGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * debug info
     * @summary debug info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public debugGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).debugGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * health check
     * @summary health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * download pneutrinoutil config as json
     * @summary download config
     * @param {string} id request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public procIdConfigGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).procIdConfigGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get process info
     * @summary get process info
     * @param {string} id request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public procIdDetailGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).procIdDetailGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * download process log file
     * @summary download log
     * @param {string} id request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public procIdLogGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).procIdLogGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * download musicxml file
     * @summary download musicxml
     * @param {string} id request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public procIdMusicxmlGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).procIdMusicxmlGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * download wav file generated by pneutrinoutil
     * @summary download wav
     * @param {string} id request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public procIdWavGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).procIdWavGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * download world wav file generated by pneutrinoutil (before NEUTRINO v3)
     * @summary download world wav
     * @param {string} id request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public procIdWorldWavGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).procIdWorldWavGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * start a pneutrinoutil process with given arguments
     * @summary start a process
     * @param {File} score musicxml
     * @param {number} [enhanceBreathiness] [0, 100]%, default: 0 (before NEUTRINO v3)
     * @param {number} [formantShift] default: 1.0 (before NEUTRINO v3)
     * @param {number} [inference] [2, 3, 4], default: 2 (before NEUTRINO v3)
     * @param {string} [model] default: MERROW
     * @param {string} [supportModel] (NEUTRINO v3)
     * @param {number} [transpose] default: 0 (NEUTRINO v3)
     * @param {number} [pitchShiftNsf] default: 0 (before NEUTRINO v3)
     * @param {number} [pitchShiftWorld] default: 0 (before NEUTRINO v3)
     * @param {number} [smoothFormant] [0, 100]%, default: 0 (before NEUTRINO v3)
     * @param {number} [smoothPitch] [0, 100]%, default: 0 (before NEUTRINO v3)
     * @param {number} [styleShift] default: 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public procPost(score: File, enhanceBreathiness?: number, formantShift?: number, inference?: number, model?: string, supportModel?: string, transpose?: number, pitchShiftNsf?: number, pitchShiftWorld?: number, smoothFormant?: number, smoothPitch?: number, styleShift?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).procPost(score, enhanceBreathiness, formantShift, inference, model, supportModel, transpose, pitchShiftNsf, pitchShiftWorld, smoothFormant, smoothPitch, styleShift, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * search processes by status, created_at, title prefix, order by created_at desc
     * @summary search processes
     * @param {number} [limit] query limit; default: 5
     * @param {string} [prefix] title prefix
     * @param {string} [status] process status; (pending|running|succeed|failed)
     * @param {string} [start] created_at
     * @param {string} [end] created_at
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public procSearchGet(limit?: number, prefix?: string, status?: string, start?: string, end?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).procSearchGet(limit, prefix, status, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get server version
     * @summary get server version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public versionGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).versionGet(options).then((request) => request(this.axios, this.basePath));
    }
}



